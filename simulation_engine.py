# simulation_engine.py
# 负责运行整个仿真循环
import numpy as np
import heat_vehicle as hv # 假设这个模块包含车辆相关的热量计算函数
import heat_cabin as ht # 假设这个模块包含座舱相关的热量计算函数
# simulation_parameters (sp) 将作为参数传递给 SimulationEngine

class SimulationEngine:
    def __init__(self, sp, cop_value):
        self.sp = sp
        # COP: Coefficient of Performance for the entire AC system (cabin + chiller)
        # For example, if COP = 2, then for 1W of mechanical compressor power, 2W of cooling is achieved.
        self.cop = cop_value
        self.n_steps = int(sp.sim_duration / sp.dt)
        self.time_sim = np.linspace(0, sp.sim_duration, self.n_steps + 1)

        # --- Initialize history arrays for temperatures ---
        self.T_motor_hist = np.zeros(self.n_steps + 1)
        self.T_inv_hist = np.zeros(self.n_steps + 1)
        self.T_batt_hist = np.zeros(self.n_steps + 1)
        self.T_cabin_hist = np.zeros(self.n_steps + 1)
        self.T_coolant_hist = np.zeros(self.n_steps + 1)

        # --- Control/State Logs ---
        self.powertrain_chiller_active_log = np.zeros(self.n_steps + 1) # Log for powertrain chiller activity
        # REMOVED: self.radiator_effectiveness_log (replaced by LTR_effectiveness_log)
        self.LTR_effectiveness_log = np.zeros(self.n_steps + 1) # NEW: Log for LTR effectiveness

        # --- Heat Flow Logs ---
        # REMOVED: self.Q_coolant_radiator_log (replaced by Q_LTR_hist)
        self.Q_LTR_hist = np.zeros(self.n_steps + 1)             # NEW: Heat rejected by LTR to ambient
        self.Q_coolant_from_LCC_hist = np.zeros(self.n_steps + 1) # NEW: Heat absorbed by coolant from LCC (refrigerant condensation)
        self.Q_coolant_chiller_actual_hist = np.zeros(self.n_steps + 1) # Heat transferred from coolant to Chiller refrigerant
        self.Q_cabin_load_total_hist = np.zeros(self.n_steps + 1)    # Total heat load on the cabin
        self.Q_cabin_cool_actual_hist = np.zeros(self.n_steps + 1) # Actual cooling power delivered to the cabin by evaporator

        # --- Input/Generation Logs ---
        self.v_vehicle_profile_hist = np.zeros(self.n_steps + 1)      # Vehicle speed
        self.Q_gen_motor_profile_hist = np.zeros(self.n_steps + 1)    # Heat generated by motor
        self.Q_gen_inv_profile_hist = np.zeros(self.n_steps + 1)      # Heat generated by inverter
        self.Q_gen_batt_profile_hist = np.zeros(self.n_steps + 1)     # Heat generated by battery
        self.P_comp_elec_profile_hist = np.zeros(self.n_steps + 1)    # Electrical power consumed by compressor

        # --- Set initial values (t=0) ---
        self.T_motor_hist[0] = sp.T_motor_init
        self.T_inv_hist[0] = sp.T_inv_init
        self.T_batt_hist[0] = sp.T_batt_init
        self.T_cabin_hist[0] = sp.T_cabin_init
        self.T_coolant_hist[0] = sp.T_coolant_init
        self.v_vehicle_profile_hist[0] = sp.v_start

        # Initial LTR effectiveness based on initial coolant temperature
        initial_coolant_temp_for_ltr = self.T_coolant_hist[0]
        initial_ltr_effectiveness = sp.LTR_effectiveness_factors[0] # Start with the lowest effectiveness level
        # Iterate through defined thresholds to find the correct effectiveness level
        for lvl_idx in range(len(sp.LTR_coolant_temp_thresholds)):
            if initial_coolant_temp_for_ltr > sp.LTR_coolant_temp_thresholds[lvl_idx]:
                # If coolant temp is above threshold, use the next effectiveness factor
                initial_ltr_effectiveness = sp.LTR_effectiveness_factors[lvl_idx + 1]
            else:
                # Coolant temp is not above this threshold, so the previous level was correct
                break
        self.LTR_effectiveness_log[0] = initial_ltr_effectiveness
        UA_LTR_eff_init = sp.UA_LTR_max * initial_ltr_effectiveness
        Q_LTR_init = max(0, UA_LTR_eff_init * (initial_coolant_temp_for_ltr - sp.T_ambient)) # LTR can only reject heat
        self.Q_LTR_hist[0] = Q_LTR_init

        # Initial cabin cooling power
        initial_cabin_temp_for_cooling = self.T_cabin_hist[0]
        Q_cabin_cool_initial = sp.cabin_cooling_power_levels[-1] # Default to max power
        for j in range(len(sp.cabin_cooling_temp_thresholds)):
            if initial_cabin_temp_for_cooling <= sp.cabin_cooling_temp_thresholds[j]:
                Q_cabin_cool_initial = sp.cabin_cooling_power_levels[j]
                break
        self.Q_cabin_cool_actual_hist[0] = max(0, Q_cabin_cool_initial)

        # Initial cabin heat load (assuming ht module functions are available)
        try:
            Q_cabin_internal_init = ht.heat_universal_func(sp.N_passengers)
            Q_cabin_conduction_body_init = ht.heat_body_func(sp.T_ambient, initial_cabin_temp_for_cooling, self.v_vehicle_profile_hist[0], sp.v_air_in_mps, sp.A_body, sp.R_body)
            Q_cabin_conduction_glass_init = ht.heat_glass_func(sp.T_ambient, initial_cabin_temp_for_cooling, sp.I_solar_summer, self.v_vehicle_profile_hist[0], sp.v_air_in_mps, sp.A_glass, sp.R_glass, sp.SHGC, sp.A_glass_sun)
            Q_cabin_ventilation_init = ht.heat_vent_summer_func(sp.N_passengers, sp.T_ambient, initial_cabin_temp_for_cooling, sp.W_out_summer, sp.W_in_target, sp.fresh_air_fraction)
            self.Q_cabin_load_total_hist[0] = Q_cabin_internal_init + Q_cabin_conduction_body_init + Q_cabin_conduction_glass_init + Q_cabin_ventilation_init
        except AttributeError:
            print("Warning: Cabin heat load functions (ht.heat_..._func) not found. Initial cabin load set to 0.")
            self.Q_cabin_load_total_hist[0] = 0


        self.powertrain_chiller_on = False # Powertrain chiller is initially off
        self.Q_coolant_chiller_actual_hist[0] = 0.0 # No heat transfer through chiller initially

        # Initial compressor power and LCC heat transfer
        Q_evap_total_needed_init = self.Q_cabin_cool_actual_hist[0] + self.Q_coolant_chiller_actual_hist[0] # Chiller is 0 initially
        P_comp_elec_init = 0.0
        P_comp_mech_init = 0.0
        if Q_evap_total_needed_init > 0 and self.cop > 0 and sp.eta_comp_drive > 0:
             P_comp_mech_init = Q_evap_total_needed_init / self.cop
             P_comp_elec_init = P_comp_mech_init / sp.eta_comp_drive
        self.P_comp_elec_profile_hist[0] = P_comp_elec_init
        self.Q_coolant_from_LCC_hist[0] = Q_evap_total_needed_init + P_comp_mech_init # Heat rejected by refrigerant in LCC

        # Initial heat generation for powertrain components (assuming hv module functions are available)
        try:
            P_wheel_init = hv.P_wheel_func(self.v_vehicle_profile_hist[0], sp.m_vehicle, sp.T_ambient)
            P_motor_in_init = hv.P_motor_func(P_wheel_init, sp.eta_motor)
            P_inv_in_init = P_motor_in_init / sp.eta_inv if sp.eta_inv > 0 else 0

            self.Q_gen_motor_profile_hist[0] = hv.Q_mot_func(P_motor_in_init, sp.eta_motor)
            self.Q_gen_inv_profile_hist[0] = hv.Q_inv_func(P_motor_in_init, sp.eta_inv) # P_motor_in is output of inverter
            P_elec_total_batt_out_init = P_inv_in_init + P_comp_elec_init
            self.Q_gen_batt_profile_hist[0] = hv.Q_batt_func(P_elec_total_batt_out_init, sp.u_batt, sp.R_int_batt)
        except AttributeError:
            print("Warning: Powertrain heat generation functions (hv.P_..._func, hv.Q_..._func) not found. Initial generations set to 0.")
            self.Q_gen_motor_profile_hist[0] = 0
            self.Q_gen_inv_profile_hist[0] = 0
            self.Q_gen_batt_profile_hist[0] = 0


    def run_simulation(self):
        sp = self.sp # shortcut for simulation parameters
        print(f"Starting simulation loop (New Logic: LCC + LTR) for {self.n_steps} steps...")

        for i in range(self.n_steps):
            # --- 0. Get current states from previous time step ---
            current_time_sec = self.time_sim[i]
            current_cabin_temp = self.T_cabin_hist[i]
            current_T_motor = self.T_motor_hist[i]
            current_T_inv = self.T_inv_hist[i]
            current_T_batt = self.T_batt_hist[i]
            current_T_coolant = self.T_coolant_hist[i]

            # --- 1. External Inputs & Heat Generation ---
            # Vehicle speed profile
            if current_time_sec <= sp.ramp_up_time_sec:
                speed_increase = (sp.v_end - sp.v_start) * (current_time_sec / sp.ramp_up_time_sec) if sp.ramp_up_time_sec > 0 else 0
                v_vehicle_current = sp.v_start + speed_increase
            else:
                v_vehicle_current = sp.v_end
            # Clamp speed to be within v_start and v_end bounds during ramp-up
            v_vehicle_current = max(min(sp.v_start, sp.v_end), min(max(sp.v_start, sp.v_end), v_vehicle_current))
            if current_time_sec >= sp.ramp_up_time_sec : v_vehicle_current = sp.v_end # Ensure it stays at v_end after ramp
            self.v_vehicle_profile_hist[i] = v_vehicle_current

            # Powertrain heat generation (Motor, Inverter)
            try:
                P_wheel = hv.P_wheel_func(v_vehicle_current, sp.m_vehicle, sp.T_ambient)
                P_motor_in = hv.P_motor_func(P_wheel, sp.eta_motor) # Power input to motor (output of inverter)
                P_inv_in = P_motor_in / sp.eta_inv if sp.eta_inv > 0 else 0 # Power input to inverter

                Q_gen_motor = hv.Q_mot_func(P_motor_in, sp.eta_motor)
                Q_gen_inv = hv.Q_inv_func(P_motor_in, sp.eta_inv) # P_motor_in is inverter output
            except AttributeError:
                P_inv_in = 0; Q_gen_motor = 0; Q_gen_inv = 0 # Fallback if hv functions are missing
            self.Q_gen_motor_profile_hist[i] = Q_gen_motor
            self.Q_gen_inv_profile_hist[i] = Q_gen_inv
            # Battery heat generation (Q_gen_batt) is calculated later as it depends on compressor power

            # Cabin heat load calculation
            try:
                Q_cabin_internal = ht.heat_universal_func(sp.N_passengers)
                Q_cabin_conduction_body = ht.heat_body_func(sp.T_ambient, current_cabin_temp, v_vehicle_current, sp.v_air_in_mps, sp.A_body, sp.R_body)
                Q_cabin_conduction_glass = ht.heat_glass_func(sp.T_ambient, current_cabin_temp, sp.I_solar_summer, v_vehicle_current, sp.v_air_in_mps, sp.A_glass, sp.R_glass, sp.SHGC, sp.A_glass_sun)
                Q_cabin_ventilation = ht.heat_vent_summer_func(sp.N_passengers, sp.T_ambient, current_cabin_temp, sp.W_out_summer, sp.W_in_target, sp.fresh_air_fraction)
                Q_cabin_load_total = Q_cabin_internal + Q_cabin_conduction_body + Q_cabin_conduction_glass + Q_cabin_ventilation
            except AttributeError:
                Q_cabin_load_total = 0 # Fallback if ht functions are missing
            self.Q_cabin_load_total_hist[i] = Q_cabin_load_total

            # --- 2. Cooling System Control & Heat Transfer ---

            # 2a. Cabin Evaporator Cooling Control
            # Determine required cabin cooling power based on cabin temperature and thresholds
            Q_cabin_cool_actual = sp.cabin_cooling_power_levels[-1] # Default to max power
            for j in range(len(sp.cabin_cooling_temp_thresholds)):
                if current_cabin_temp <= sp.cabin_cooling_temp_thresholds[j]:
                    Q_cabin_cool_actual = sp.cabin_cooling_power_levels[j]
                    break
            Q_cabin_cool_actual = max(0, Q_cabin_cool_actual) # Cooling power cannot be negative
            self.Q_cabin_cool_actual_hist[i] = Q_cabin_cool_actual

            # 2b. Powertrain Chiller Control Logic (determines if chiller *needs* to provide cooling to coolant loop)
            # Conditions to start powertrain cooling via chiller
            start_cooling_powertrain = (current_T_motor > sp.T_motor_target) or \
                                       (current_T_inv > sp.T_inv_target) or \
                                       (current_T_batt > sp.T_batt_target_high)
            # Conditions to stop powertrain cooling via chiller
            stop_cooling_powertrain = (current_T_motor < sp.T_motor_stop_cool) and \
                                      (current_T_inv < sp.T_inv_stop_cool) and \
                                      (current_T_batt < sp.T_batt_stop_cool)

            if start_cooling_powertrain:
                self.powertrain_chiller_on = True
            elif stop_cooling_powertrain:
                self.powertrain_chiller_on = False
            self.powertrain_chiller_active_log[i] = 1 if self.powertrain_chiller_on else 0

            # 2c. Chiller Heat Transfer (from Coolant to Refrigerant)
            # Potential heat transfer from coolant to chiller's refrigerant evaporator
            Q_chiller_potential = 0
            if current_T_coolant > sp.T_evap_sat_for_UA_calc: # Chiller can only cool if coolant is warmer than evap temp
                 Q_chiller_potential = sp.UA_coolant_chiller * (current_T_coolant - sp.T_evap_sat_for_UA_calc)
            Q_chiller_potential = max(0, Q_chiller_potential) # Ensure non-negative

            # Actual heat transfer by chiller depends on if it's ON and its max capacity
            Q_coolant_chiller_actual = 0
            if self.powertrain_chiller_on:
                Q_coolant_chiller_actual = min(Q_chiller_potential, sp.max_chiller_cool_power)
            self.Q_coolant_chiller_actual_hist[i] = Q_coolant_chiller_actual # Heat *leaving* coolant *to* chiller refrigerant

            # 2d. Total Refrigerant Evaporation Load
            # This is the sum of heat absorbed by cabin evaporator and chiller evaporator
            Q_evap_total_needed = Q_cabin_cool_actual + Q_coolant_chiller_actual

            # 2e. Compressor Power Calculation
            P_comp_elec = 0.0 # Electrical power to compressor
            P_comp_mech = 0.0 # Mechanical power from compressor motor
            if Q_evap_total_needed > 0 and self.cop > 0 and sp.eta_comp_drive > 0:
                P_comp_mech = Q_evap_total_needed / self.cop # Mechanical power needed for cooling
                P_comp_elec = P_comp_mech / sp.eta_comp_drive  # Electrical power accounting for drive efficiency
            self.P_comp_elec_profile_hist[i] = P_comp_elec

            # 2f. LCC Heat Transfer (from Refrigerant to Coolant)
            # Heat rejected by refrigerant in LCC = Total Evaporation Load + Compressor Mechanical Work.
            # This heat is absorbed by the coolant loop.
            Q_coolant_from_LCC = Q_evap_total_needed + P_comp_mech
            self.Q_coolant_from_LCC_hist[i] = Q_coolant_from_LCC # Heat *entering* coolant *from* LCC (refrigerant)

            # 2g. Battery Heat Generation (calculated now that compressor power P_comp_elec is known)
            P_elec_total_batt_out = P_inv_in + P_comp_elec # Total electrical load on battery
            try:
                Q_gen_batt = hv.Q_batt_func(P_elec_total_batt_out, sp.u_batt, sp.R_int_batt)
            except AttributeError:
                Q_gen_batt = 0 # Fallback
            self.Q_gen_batt_profile_hist[i] = Q_gen_batt

            # 2h. Heat Transfer from Powertrain Components to Coolant
            Q_motor_to_coolant = sp.UA_motor_coolant * (current_T_motor - current_T_coolant)
            Q_inv_to_coolant = sp.UA_inv_coolant * (current_T_inv - current_T_coolant)
            Q_batt_to_coolant = sp.UA_batt_coolant * (current_T_batt - current_T_coolant)

            # 2i. External Radiator (LTR) Heat Rejection (from Coolant to Ambient)
            # Determine current LTR effectiveness based on coolant temperature and defined thresholds/factors
            current_LTR_effectiveness = sp.LTR_effectiveness_factors[0] # Default to lowest effectiveness
            for lvl_idx in range(len(sp.LTR_coolant_temp_thresholds)):
                if current_T_coolant > sp.LTR_coolant_temp_thresholds[lvl_idx]:
                    current_LTR_effectiveness = sp.LTR_effectiveness_factors[lvl_idx + 1]
                else:
                    break # Coolant temp is below this threshold, use the previously set effectiveness
            self.LTR_effectiveness_log[i] = current_LTR_effectiveness

            # Calculate effective UA for LTR and heat rejected to ambient
            UA_LTR_effective = sp.UA_LTR_max * current_LTR_effectiveness
            Q_LTR_potential = UA_LTR_effective * (current_T_coolant - sp.T_ambient)
            Q_LTR_to_ambient = max(0, Q_LTR_potential) # Radiator can only reject heat (coolant warmer than ambient)
            self.Q_LTR_hist[i] = Q_LTR_to_ambient # Heat *leaving* coolant *to* ambient via LTR

            # --- 3. Temperature Updates (using Euler forward integration) ---

            # 3a. Coolant Temperature Update
            # Coolant heat flow:
            # Gains: from LCC (refrigerant), from Motor, from Inverter, from Battery
            # Losses: to LTR (ambient), to Chiller (refrigerant)
            Q_coolant_net = (Q_coolant_from_LCC + Q_motor_to_coolant + Q_inv_to_coolant + Q_batt_to_coolant) \
                          - (Q_LTR_to_ambient + Q_coolant_chiller_actual)

            dT_coolant_dt = Q_coolant_net / sp.mc_coolant if sp.mc_coolant > 0 else 0

            # 3b. Component Temperature Updates
            dT_motor_dt = (Q_gen_motor - Q_motor_to_coolant) / sp.mc_motor if sp.mc_motor > 0 else 0
            dT_inv_dt = (Q_gen_inv - Q_inv_to_coolant) / sp.mc_inverter if sp.mc_inverter > 0 else 0
            dT_batt_dt = (Q_gen_batt - Q_batt_to_coolant) / sp.mc_battery if sp.mc_battery > 0 else 0
            dT_cabin_dt = (Q_cabin_load_total - Q_cabin_cool_actual) / sp.mc_cabin if sp.mc_cabin > 0 else 0

            # --- 4. Store results for the next time step (i+1) ---
            self.T_motor_hist[i+1] = current_T_motor + dT_motor_dt * sp.dt
            self.T_inv_hist[i+1] = current_T_inv + dT_inv_dt * sp.dt
            self.T_batt_hist[i+1] = current_T_batt + dT_batt_dt * sp.dt
            self.T_cabin_hist[i+1] = current_cabin_temp + dT_cabin_dt * sp.dt
            self.T_coolant_hist[i+1] = current_T_coolant + dT_coolant_dt * sp.dt

        print(f"Simulation loop finished (New Logic: LCC + LTR) after {self.n_steps} steps.")
        self._fill_last_step_values() # Fill values for the very last data point in logs

        # --- 5. Prepare results dictionary ---
        simulation_results = {
            "time_sim": self.time_sim,
            "temperatures_data": {
                'motor': self.T_motor_hist, 'inv': self.T_inv_hist, 'batt': self.T_batt_hist,
                'cabin': self.T_cabin_hist, 'coolant': self.T_coolant_hist
            },
            "heat_gen_data": {
                'motor': self.Q_gen_motor_profile_hist,
                'inv': self.Q_gen_inv_profile_hist,
                'batt': self.Q_gen_batt_profile_hist,
                'cabin_load': self.Q_cabin_load_total_hist
            },
            "cooling_system_logs": {
                'chiller_active': self.powertrain_chiller_active_log,
                'LTR_effectiveness': self.LTR_effectiveness_log,      # NEW
                'Q_LTR_to_ambient': self.Q_LTR_hist,                   # NEW (replaces Q_radiator)
                'Q_coolant_from_LCC': self.Q_coolant_from_LCC_hist,    # NEW
                'Q_coolant_to_chiller': self.Q_coolant_chiller_actual_hist, # Renamed for clarity
                'Q_cabin_evap_cooling': self.Q_cabin_cool_actual_hist      # Renamed for clarity
                # REMOVED: 'radiator_effectiveness', 'Q_radiator'
            },
            "ac_power_log": self.P_comp_elec_profile_hist,
            "speed_profile": self.v_vehicle_profile_hist
        }
        return simulation_results

    def _fill_last_step_values(self):
        """
        Ensure the last data point of logged profiles (index n_steps) is consistent.
        Typically, for profiles that are inputs or states derived within the loop,
        the value at n_steps can be a copy of n_steps-1 or recalculated if it's an input.
        Temperatures are already calculated up to n_steps in the loop.
        """
        sp = self.sp
        n = self.n_steps # index for the last point in arrays of size n_steps + 1

        # Vehicle speed for the last point (recalculate as it's an input profile)
        current_time_sec_last = self.time_sim[n]
        if current_time_sec_last <= sp.ramp_up_time_sec:
            speed_increase_last = (sp.v_end - sp.v_start) * (current_time_sec_last / sp.ramp_up_time_sec) if sp.ramp_up_time_sec > 0 else 0
            v_last = sp.v_start + speed_increase_last
        else:
            v_last = sp.v_end
        v_last = max(min(sp.v_start,sp.v_end), min(max(sp.v_start,sp.v_end), v_last))
        if current_time_sec_last >= sp.ramp_up_time_sec : v_last = sp.v_end
        self.v_vehicle_profile_hist[n] = v_last

        # For other logs that are results of calculations within the loop,
        # we can copy the value from the previous step (n-1) if n > 0.
        # If n=0 (only one point in time), these should have been calculated in __init__.
        if n > 0:
            self.powertrain_chiller_active_log[n] = self.powertrain_chiller_active_log[n-1]
            self.LTR_effectiveness_log[n] = self.LTR_effectiveness_log[n-1]
            self.Q_LTR_hist[n] = self.Q_LTR_hist[n-1]
            self.Q_coolant_from_LCC_hist[n] = self.Q_coolant_from_LCC_hist[n-1]
            self.Q_coolant_chiller_actual_hist[n] = self.Q_coolant_chiller_actual_hist[n-1]
            self.Q_cabin_load_total_hist[n] = self.Q_cabin_load_total_hist[n-1] # This is an input, could be recalculated
            self.Q_gen_motor_profile_hist[n] = self.Q_gen_motor_profile_hist[n-1] # Also input-driven
            self.Q_gen_inv_profile_hist[n] = self.Q_gen_inv_profile_hist[n-1]   # Also input-driven
            self.Q_gen_batt_profile_hist[n] = self.Q_gen_batt_profile_hist[n-1] # Result of calculation
            self.P_comp_elec_profile_hist[n] = self.P_comp_elec_profile_hist[n-1] # Result of calculation
            self.Q_cabin_cool_actual_hist[n] = self.Q_cabin_cool_actual_hist[n-1] # Result of calculation

            # Optionally, recalculate input-driven values like Q_gen for the last step
            # For simplicity here, we copy, assuming dt is small enough that values don't change drastically.
            # However, for Q_cabin_load_total, Q_gen_motor, Q_gen_inv, Q_gen_batt it might be more accurate
            # to recalculate based on T[n] and v[n].
            # Example recalculation for Q_gen_batt for the last step:
            try:
                P_wheel_last = hv.P_wheel_func(self.v_vehicle_profile_hist[n], sp.m_vehicle, sp.T_ambient)
                P_motor_in_last = hv.P_motor_func(P_wheel_last, sp.eta_motor)
                P_inv_in_last = P_motor_in_last / sp.eta_inv if sp.eta_inv > 0 else 0
                self.Q_gen_motor_profile_hist[n] = hv.Q_mot_func(P_motor_in_last, sp.eta_motor)
                self.Q_gen_inv_profile_hist[n] = hv.Q_inv_func(P_motor_in_last, sp.eta_inv)

                P_elec_total_batt_out_last = P_inv_in_last + self.P_comp_elec_profile_hist[n] # use P_comp[n] from copy
                self.Q_gen_batt_profile_hist[n] = hv.Q_batt_func(P_elec_total_batt_out_last, sp.u_batt, sp.R_int_batt)

                T_cabin_last = self.T_cabin_hist[n]
                Q_cabin_internal_last = ht.heat_universal_func(sp.N_passengers)
                Q_cabin_conduction_body_last = ht.heat_body_func(sp.T_ambient, T_cabin_last, self.v_vehicle_profile_hist[n], sp.v_air_in_mps, sp.A_body, sp.R_body)
                Q_cabin_conduction_glass_last = ht.heat_glass_func(sp.T_ambient, T_cabin_last, sp.I_solar_summer, self.v_vehicle_profile_hist[n], sp.v_air_in_mps, sp.A_glass, sp.R_glass, sp.SHGC, sp.A_glass_sun)
                Q_cabin_ventilation_last = ht.heat_vent_summer_func(sp.N_passengers, sp.T_ambient, T_cabin_last, sp.W_out_summer, sp.W_in_target, sp.fresh_air_fraction)
                self.Q_cabin_load_total_hist[n] = Q_cabin_internal_last + Q_cabin_conduction_body_last + Q_cabin_conduction_glass_last + Q_cabin_ventilation_last
            except AttributeError:
                # If hv or ht functions are missing, the copied values remain.
                pass


        elif n == 0: # Simulation has only one point (t=0), values set in __init__
            # Most values are already calculated in __init__.
            # If any were dependent on loop iterations that didn't happen, ensure they are correct.
            # For instance, LTR_effectiveness_log[0] and Q_LTR_hist[0] are set in __init__.
            # Q_gen_batt_profile_hist[0] is also set in __init__.
            pass